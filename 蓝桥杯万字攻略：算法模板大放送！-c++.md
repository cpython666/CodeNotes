# å‰è¨€
ğŸ˜ğŸ¥³ğŸ˜ğŸ¤ ğŸ˜®ğŸ¤–ğŸ™ˆğŸ’­ğŸ³ğŸ±
å½“ä»Šç¤¾ä¼šï¼Œç¨‹åºè®¾è®¡å·²æˆä¸ºä¸€ä¸ªä¸å¯æˆ–ç¼ºçš„æŠ€èƒ½ã€‚è€Œç®—æ³•åˆ™æ˜¯ç¨‹åºè®¾è®¡ä¸­æœ€åŸºç¡€ã€æœ€é‡è¦çš„ä¸€éƒ¨åˆ†ï¼Œä¹Ÿæ˜¯å„ç§ç¼–ç¨‹ç«èµ›ä¸­æœ€é‡è¦çš„è€ƒå¯Ÿå†…å®¹ä¹‹ä¸€ã€‚åœ¨ä¼—å¤šç¼–ç¨‹ç«èµ›ä¸­ï¼Œè“æ¡¥æ¯æ— ç–‘æ˜¯å…¶ä¸­æœ€å…·æœ‰ä»£è¡¨æ€§å’Œå½±å“åŠ›çš„æ¯”èµ›ä¹‹ä¸€ã€‚å› æ­¤ï¼Œå­¦ä¹ è“æ¡¥æ¯ç®—æ³•æ¨¡æ¿å¯¹äºæé«˜æˆ‘ä»¬çš„ç®—æ³•æ°´å¹³ã€æ‹“å®½æˆ‘ä»¬çš„æ€ç»´æ–¹å¼éƒ½è‡³å…³é‡è¦ã€‚æœ¬æ–‡å°†ä»‹ç»ä¸€äº›å¸¸è§çš„è“æ¡¥æ¯ç®—æ³•æ¨¡æ¿ï¼Œå¹¶é€šè¿‡å®ä¾‹è¿›è¡Œè®²è§£ï¼Œå¸Œæœ›èƒ½ä¸ºè¯»è€…æä¾›ä¸€äº›å¯å‘å’Œå¸®åŠ©ã€‚


---
# ä¸»è¦å†…å®¹
ğŸ¦ğŸ¦ğŸ¦€ğŸ¦‘ğŸ¦ª

# ç”±æ•°æ®èŒƒå›´åæ¨ç®—æ³•å¤æ‚åº¦ä»¥åŠç®—æ³•å†…å®¹

ä¸€èˆ¬ACMæˆ–è€…ç¬”è¯•é¢˜çš„æ—¶é—´é™åˆ¶æ˜¯1ç§’æˆ–2ç§’ã€‚  
åœ¨è¿™ç§æƒ…å†µä¸‹ï¼ŒC++ä»£ç ä¸­çš„æ“ä½œæ¬¡æ•°æ§åˆ¶åœ¨ $10^7 \sim 10^8$ ä¸ºæœ€ä½³ã€‚

ä¸‹é¢ç»™å‡ºåœ¨ä¸åŒæ•°æ®èŒƒå›´ä¸‹ï¼Œä»£ç çš„æ—¶é—´å¤æ‚åº¦å’Œç®—æ³•è¯¥å¦‚ä½•é€‰æ‹©ï¼š

1.  $n \le 30$, æŒ‡æ•°çº§åˆ«, dfs+å‰ªæï¼ŒçŠ¶æ€å‹ç¼©dp
2.  $n \le 100$ => $O(n^3)$ï¼Œfloydï¼Œdpï¼Œé«˜æ–¯æ¶ˆå…ƒ
3.  $n \le 1000$ => $O(n^2)$ï¼Œ$O(n^2logn)$ï¼Œdpï¼ŒäºŒåˆ†ï¼Œæœ´ç´ ç‰ˆDijkstraã€æœ´ç´ ç‰ˆPrimã€Bellman-Ford
4.  $n \le 10000$ => $O(n * \sqrt n)$ï¼Œå—çŠ¶é“¾è¡¨ã€åˆ†å—ã€è«é˜Ÿ
5.  $n \le 100000$ => $O(nlogn)$ => å„ç§sortï¼Œçº¿æ®µæ ‘ã€æ ‘çŠ¶æ•°ç»„ã€set/mapã€heapã€æ‹“æ‰‘æ’åºã€dijkstra+heapã€prim+heapã€Kruskalã€spfaã€æ±‚å‡¸åŒ…ã€æ±‚åŠå¹³é¢äº¤ã€äºŒåˆ†ã€CDQåˆ†æ²»ã€æ•´ä½“äºŒåˆ†ã€åç¼€æ•°ç»„ã€æ ‘é“¾å‰–åˆ†ã€åŠ¨æ€æ ‘
6.  $n \le 1000000$ => $O(n)$, ä»¥åŠå¸¸æ•°è¾ƒå°çš„ $O(nlogn)$ ç®—æ³• => å•è°ƒé˜Ÿåˆ—ã€ hashã€åŒæŒ‡é’ˆæ‰«æã€å¹¶æŸ¥é›†ï¼Œkmpã€ACè‡ªåŠ¨æœºï¼Œå¸¸æ•°æ¯”è¾ƒå°çš„ $O(nlogn)$ çš„åšæ³•ï¼šsortã€æ ‘çŠ¶æ•°ç»„ã€heapã€dijkstraã€spfa
7.  $n \le 10000000$ => $O(n)$ï¼ŒåŒæŒ‡é’ˆæ‰«æã€kmpã€ACè‡ªåŠ¨æœºã€çº¿æ€§ç­›ç´ æ•°
8.  $n \le 10^9$ => $O(\sqrt n)$ï¼Œåˆ¤æ–­è´¨æ•°
9.  $n \le 10^{18}$ => $O(logn)$ï¼Œæœ€å¤§å…¬çº¦æ•°ï¼Œå¿«é€Ÿå¹‚ï¼Œæ•°ä½DP
10.  $n \le 10^{1000}$ => $O((logn)^2)$ï¼Œé«˜ç²¾åº¦åŠ å‡ä¹˜é™¤
11.  $n \le 10^{100000}$ => $O(logk \times loglogk)ï¼Œkè¡¨ç¤ºä½æ•°$ï¼Œé«˜ç²¾åº¦åŠ å‡ã€FFT/NTT ç”±æ•°æ®èŒƒå›´åæ¨ç®—æ³•

# åŸºç¡€ç®—æ³•
## å¿«é€Ÿæ’åºç®—æ³•æ¨¡æ¿ 
```c
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
## å½’å¹¶æ’åºç®—æ³•æ¨¡æ¿
```c
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];

    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];

    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
## æ•´æ•°äºŒåˆ†ç®—æ³•æ¨¡æ¿
```c
bool check(int x) {/* ... */} // æ£€æŸ¥xæ˜¯å¦æ»¡è¶³æŸç§æ€§è´¨

// åŒºé—´[l, r]è¢«åˆ’åˆ†æˆ[l, mid]å’Œ[mid + 1, r]æ—¶ä½¿ç”¨ï¼š
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()åˆ¤æ–­midæ˜¯å¦æ»¡è¶³æ€§è´¨
        else l = mid + 1;
    }
    return l;
}
// åŒºé—´[l, r]è¢«åˆ’åˆ†æˆ[l, mid - 1]å’Œ[mid, r]æ—¶ä½¿ç”¨ï¼š
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```
## æµ®ç‚¹æ•°äºŒåˆ†ç®—æ³•æ¨¡æ¿
```c
bool check(double x) {/* ... */} // æ£€æŸ¥xæ˜¯å¦æ»¡è¶³æŸç§æ€§è´¨

double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps è¡¨ç¤ºç²¾åº¦ï¼Œå–å†³äºé¢˜ç›®å¯¹ç²¾åº¦çš„è¦æ±‚
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```
## é«˜ç²¾åº¦åŠ æ³• 
```c
// C = A + B, A >= 0, B >= 0
vector<int> add(vector<int> &A, vector<int> &B)
{
    if (A.size() < B.size()) return add(B, A);

    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ )
    {
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }

    if (t) C.push_back(t);
    return C;
}
```
## é«˜ç²¾åº¦å‡æ³•
```c
// C = A - B, æ»¡è¶³A >= B, A >= 0, B >= 0
vector<int> sub(vector<int> &A, vector<int> &B)
{
    vector<int> C;
    for (int i = 0, t = 0; i < A.size(); i ++ )
    {
        t = A[i] - t;
        if (i < B.size()) t -= B[i];
        C.push_back((t + 10) % 10);
        if (t < 0) t = 1;
        else t = 0;
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```
## é«˜ç²¾åº¦ä¹˜ä½ç²¾åº¦
```c
// C = A * b, A >= 0, b >= 0
vector<int> mul(vector<int> &A, int b)
{
    vector<int> C;

    int t = 0;
    for (int i = 0; i < A.size() || t; i ++ )
    {
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();

    return C;
}
```
## é«˜ç²¾åº¦é™¤ä»¥ä½ç²¾åº¦
```c
// A / b = C ... r, A >= 0, b > 0
vector<int> div(vector<int> &A, int b, int &r)
{
    vector<int> C;
    r = 0;
    for (int i = A.size() - 1; i >= 0; i -- )
    {
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    reverse(C.begin(), C.end());
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```
## ä¸€ç»´å‰ç¼€å’Œ
```c
S[i] = a[1] + a[2] + ... a[i]
a[l] + ... + a[r] = S[r] - S[l - 1]
```
## äºŒç»´å‰ç¼€å’Œ 
```c
S[i, j] = ç¬¬iè¡Œjåˆ—æ ¼å­å·¦ä¸Šéƒ¨åˆ†æ‰€æœ‰å…ƒç´ çš„å’Œ
ä»¥(x1, y1)ä¸ºå·¦ä¸Šè§’ï¼Œ(x2, y2)ä¸ºå³ä¸‹è§’çš„å­çŸ©é˜µçš„å’Œä¸ºï¼š
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
## ä¸€ç»´å·®åˆ†
```c
ç»™åŒºé—´[l, r]ä¸­çš„æ¯ä¸ªæ•°åŠ ä¸Šcï¼šB[l] += c, B[r + 1] -= c
```
## äºŒç»´å·®åˆ†
```c
ç»™ä»¥(x1, y1)ä¸ºå·¦ä¸Šè§’ï¼Œ(x2, y2)ä¸ºå³ä¸‹è§’çš„å­çŸ©é˜µä¸­çš„æ‰€æœ‰å…ƒç´ åŠ ä¸Šcï¼š
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
## ä½è¿ç®—
```c
æ±‚nçš„ç¬¬kä½æ•°å­—: n >> k & 1
è¿”å›nçš„æœ€åä¸€ä½1ï¼šlowbit(n) = n & -n
```
## åŒæŒ‡é’ˆç®—æ³•
```c
for (int i = 0, j = 0; i < n; i ++ )
{
    while (j < i && check(i, j)) j ++ ;

    // å…·ä½“é—®é¢˜çš„é€»è¾‘
}
å¸¸è§é—®é¢˜åˆ†ç±»ï¼š
    (1) å¯¹äºä¸€ä¸ªåºåˆ—ï¼Œç”¨ä¸¤ä¸ªæŒ‡é’ˆç»´æŠ¤ä¸€æ®µåŒºé—´
    (2) å¯¹äºä¸¤ä¸ªåºåˆ—ï¼Œç»´æŠ¤æŸç§æ¬¡åºï¼Œæ¯”å¦‚å½’å¹¶æ’åºä¸­åˆå¹¶ä¸¤ä¸ªæœ‰åºåºåˆ—çš„æ“ä½œ
```
## ç¦»æ•£åŒ–
```c
vector<int> alls; // å­˜å‚¨æ‰€æœ‰å¾…ç¦»æ•£åŒ–çš„å€¼
sort(alls.begin(), alls.end()); // å°†æ‰€æœ‰å€¼æ’åº
alls.erase(unique(alls.begin(), alls.end()), alls.end());   // å»æ‰é‡å¤å…ƒç´ 

// äºŒåˆ†æ±‚å‡ºxå¯¹åº”çš„ç¦»æ•£åŒ–çš„å€¼
int find(int x) // æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤§äºç­‰äºxçš„ä½ç½®
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1; // æ˜ å°„åˆ°1, 2, ...n
}
```
## åŒºé—´åˆå¹¶
```c
// å°†æ‰€æœ‰å­˜åœ¨äº¤é›†çš„åŒºé—´åˆå¹¶
void merge(vector<PII> &segs)
{
    vector<PII> res;

    sort(segs.begin(), segs.end());

    int st = -2e9, ed = -2e9;
    for (auto seg : segs)
        if (ed < seg.first)
        {
            if (st != -2e9) res.push_back({st, ed});
            st = seg.first, ed = seg.second;
        }
        else ed = max(ed, seg.second);

    if (st != -2e9) res.push_back({st, ed});

    segs = res;
}
```
# æ•°æ®ç»“æ„
## å•é“¾è¡¨
```c
// headå­˜å‚¨é“¾è¡¨å¤´ï¼Œe[]å­˜å‚¨èŠ‚ç‚¹çš„å€¼ï¼Œne[]å­˜å‚¨èŠ‚ç‚¹çš„nextæŒ‡é’ˆï¼Œidxè¡¨ç¤ºå½“å‰ç”¨åˆ°äº†å“ªä¸ªèŠ‚ç‚¹
int head, e[N], ne[N], idx;

// åˆå§‹åŒ–
void init()
{
    head = -1;
    idx = 0;
}

// åœ¨é“¾è¡¨å¤´æ’å…¥ä¸€ä¸ªæ•°a
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}

// å°†å¤´ç»“ç‚¹åˆ é™¤ï¼Œéœ€è¦ä¿è¯å¤´ç»“ç‚¹å­˜åœ¨
void remove()
{
    head = ne[head];
}
```
## åŒé“¾è¡¨
```c
// e[]è¡¨ç¤ºèŠ‚ç‚¹çš„å€¼ï¼Œl[]è¡¨ç¤ºèŠ‚ç‚¹çš„å·¦æŒ‡é’ˆï¼Œr[]è¡¨ç¤ºèŠ‚ç‚¹çš„å³æŒ‡é’ˆï¼Œidxè¡¨ç¤ºå½“å‰ç”¨åˆ°äº†å“ªä¸ªèŠ‚ç‚¹
int e[N], l[N], r[N], idx;

// åˆå§‹åŒ–
void init()
{
    //0æ˜¯å·¦ç«¯ç‚¹ï¼Œ1æ˜¯å³ç«¯ç‚¹
    r[0] = 1, l[1] = 0;
    idx = 2;
}

// åœ¨èŠ‚ç‚¹açš„å³è¾¹æ’å…¥ä¸€ä¸ªæ•°x
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}

// åˆ é™¤èŠ‚ç‚¹a
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```
## æ ˆ
```c
// ttè¡¨ç¤ºæ ˆé¡¶
int stk[N], tt = 0;

// å‘æ ˆé¡¶æ’å…¥ä¸€ä¸ªæ•°
stk[ ++ tt] = x;

// ä»æ ˆé¡¶å¼¹å‡ºä¸€ä¸ªæ•°
tt -- ;

// æ ˆé¡¶çš„å€¼
stk[tt];

// åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœ tt > 0ï¼Œåˆ™è¡¨ç¤ºä¸ä¸ºç©º
if (tt > 0)
{

}
```
## é˜Ÿåˆ—
1. æ™®é€šé˜Ÿåˆ—
```c
// hh è¡¨ç¤ºé˜Ÿå¤´ï¼Œttè¡¨ç¤ºé˜Ÿå°¾
int q[N], hh = 0, tt = -1;

// å‘é˜Ÿå°¾æ’å…¥ä¸€ä¸ªæ•°
q[ ++ tt] = x;

// ä»é˜Ÿå¤´å¼¹å‡ºä¸€ä¸ªæ•°
hh ++ ;

// é˜Ÿå¤´çš„å€¼
q[hh];

// åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœ hh <= ttï¼Œåˆ™è¡¨ç¤ºä¸ä¸ºç©º
if (hh <= tt)
{

}
```
2. å¾ªç¯é˜Ÿåˆ—
```c
// hh è¡¨ç¤ºé˜Ÿå¤´ï¼Œttè¡¨ç¤ºé˜Ÿå°¾çš„åä¸€ä¸ªä½ç½®
int q[N], hh = 0, tt = 0;

// å‘é˜Ÿå°¾æ’å…¥ä¸€ä¸ªæ•°
q[tt ++ ] = x;
if (tt == N) tt = 0;

// ä»é˜Ÿå¤´å¼¹å‡ºä¸€ä¸ªæ•°
hh ++ ;
if (hh == N) hh = 0;

// é˜Ÿå¤´çš„å€¼
q[hh];

// åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœhh != ttï¼Œåˆ™è¡¨ç¤ºä¸ä¸ºç©º
if (hh != tt)
{

}
```
## å•è°ƒæ ˆ
```c
å¸¸è§æ¨¡å‹ï¼šæ‰¾å‡ºæ¯ä¸ªæ•°å·¦è¾¹ç¦»å®ƒæœ€è¿‘çš„æ¯”å®ƒå¤§/å°çš„æ•°
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
    while (tt && check(stk[tt], i)) tt -- ;
    stk[ ++ tt] = i;
}
```
## å•è°ƒé˜Ÿåˆ—
```
å¸¸è§æ¨¡å‹ï¼šæ‰¾å‡ºæ»‘åŠ¨çª—å£ä¸­çš„æœ€å¤§å€¼/æœ€å°å€¼
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
    while (hh <= tt && check_out(q[hh])) hh ++ ;  // åˆ¤æ–­é˜Ÿå¤´æ˜¯å¦æ»‘å‡ºçª—å£
    while (hh <= tt && check(q[tt], i)) tt -- ;
    q[ ++ tt] = i;
}
```
## KMP
```c
// s[]æ˜¯é•¿æ–‡æœ¬ï¼Œp[]æ˜¯æ¨¡å¼ä¸²ï¼Œnæ˜¯sçš„é•¿åº¦ï¼Œmæ˜¯pçš„é•¿åº¦
æ±‚æ¨¡å¼ä¸²çš„Nextæ•°ç»„ï¼š
for (int i = 2, j = 0; i <= m; i ++ )
{
    while (j && p[i] != p[j + 1]) j = ne[j];
    if (p[i] == p[j + 1]) j ++ ;
    ne[i] = j;
}

// åŒ¹é…
for (int i = 1, j = 0; i <= n; i ++ )
{
    while (j && s[i] != p[j + 1]) j = ne[j];
    if (s[i] == p[j + 1]) j ++ ;
    if (j == m)
    {
        j = ne[j];
        // åŒ¹é…æˆåŠŸåçš„é€»è¾‘
    }
}
```
## Trieæ ‘
```c
int son[N][26], cnt[N], idx;
// 0å·ç‚¹æ—¢æ˜¯æ ¹èŠ‚ç‚¹ï¼Œåˆæ˜¯ç©ºèŠ‚ç‚¹
// son[][]å­˜å‚¨æ ‘ä¸­æ¯ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹
// cnt[]å­˜å‚¨ä»¥æ¯ä¸ªèŠ‚ç‚¹ç»“å°¾çš„å•è¯æ•°é‡

// æ’å…¥ä¸€ä¸ªå­—ç¬¦ä¸²
void insert(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] = ++ idx;
        p = son[p][u];
    }
    cnt[p] ++ ;
}

// æŸ¥è¯¢å­—ç¬¦ä¸²å‡ºç°çš„æ¬¡æ•°
int query(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}
```
## å¹¶æŸ¥é›†
```c
(1)æœ´ç´ å¹¶æŸ¥é›†ï¼š

    int p[N]; //å­˜å‚¨æ¯ä¸ªç‚¹çš„ç¥–å®—èŠ‚ç‚¹

    // è¿”å›xçš„ç¥–å®—èŠ‚ç‚¹
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }

    // åˆå§‹åŒ–ï¼Œå‡å®šèŠ‚ç‚¹ç¼–å·æ˜¯1~n
    for (int i = 1; i <= n; i ++ ) p[i] = i;

    // åˆå¹¶aå’Œbæ‰€åœ¨çš„ä¸¤ä¸ªé›†åˆï¼š
    p[find(a)] = find(b);


(2)ç»´æŠ¤sizeçš„å¹¶æŸ¥é›†ï¼š

    int p[N], size[N];
    //p[]å­˜å‚¨æ¯ä¸ªç‚¹çš„ç¥–å®—èŠ‚ç‚¹, size[]åªæœ‰ç¥–å®—èŠ‚ç‚¹çš„æœ‰æ„ä¹‰ï¼Œè¡¨ç¤ºç¥–å®—èŠ‚ç‚¹æ‰€åœ¨é›†åˆä¸­çš„ç‚¹çš„æ•°é‡

    // è¿”å›xçš„ç¥–å®—èŠ‚ç‚¹
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }

    // åˆå§‹åŒ–ï¼Œå‡å®šèŠ‚ç‚¹ç¼–å·æ˜¯1~n
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        size[i] = 1;
    }

    // åˆå¹¶aå’Œbæ‰€åœ¨çš„ä¸¤ä¸ªé›†åˆï¼š
    size[find(b)] += size[find(a)];
    p[find(a)] = find(b);


(3)ç»´æŠ¤åˆ°ç¥–å®—èŠ‚ç‚¹è·ç¦»çš„å¹¶æŸ¥é›†ï¼š

    int p[N], d[N];
    //p[]å­˜å‚¨æ¯ä¸ªç‚¹çš„ç¥–å®—èŠ‚ç‚¹, d[x]å­˜å‚¨xåˆ°p[x]çš„è·ç¦»

    // è¿”å›xçš„ç¥–å®—èŠ‚ç‚¹
    int find(int x)
    {
        if (p[x] != x)
        {
            int u = find(p[x]);
            d[x] += d[p[x]];
            p[x] = u;
        }
        return p[x];
    }

    // åˆå§‹åŒ–ï¼Œå‡å®šèŠ‚ç‚¹ç¼–å·æ˜¯1~n
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        d[i] = 0;
    }

    // åˆå¹¶aå’Œbæ‰€åœ¨çš„ä¸¤ä¸ªé›†åˆï¼š
    p[find(a)] = find(b);
    d[find(a)] = distance; // æ ¹æ®å…·ä½“é—®é¢˜ï¼Œåˆå§‹åŒ–find(a)çš„åç§»é‡
```
## å †
```c
// h[N]å­˜å‚¨å †ä¸­çš„å€¼, h[1]æ˜¯å †é¡¶ï¼Œxçš„å·¦å„¿å­æ˜¯2x, å³å„¿å­æ˜¯2x + 1
// ph[k]å­˜å‚¨ç¬¬kä¸ªæ’å…¥çš„ç‚¹åœ¨å †ä¸­çš„ä½ç½®
// hp[k]å­˜å‚¨å †ä¸­ä¸‹æ ‡æ˜¯kçš„ç‚¹æ˜¯ç¬¬å‡ ä¸ªæ’å…¥çš„
int h[N], ph[N], hp[N], size;

// äº¤æ¢ä¸¤ä¸ªç‚¹ï¼ŒåŠå…¶æ˜ å°„å…³ç³»
void heap_swap(int a, int b)
{
    swap(ph[hp[a]],ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
}

void down(int u)
{
    int t = u;
    if (u * 2 <= size && h[u * 2] < h[t]) t = u * 2;
    if (u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
    if (u != t)
    {
        heap_swap(u, t);
        down(t);
    }
}

void up(int u)
{
    while (u / 2 && h[u] < h[u / 2])
    {
        heap_swap(u, u / 2);
        u >>= 1;
    }
}

// O(n)å»ºå †
for (int i = n / 2; i; i -- ) down(i);
```
## ä¸€èˆ¬å“ˆå¸Œ
```c
(1) æ‹‰é“¾æ³•
    int h[N], e[N], ne[N], idx;

    // å‘å“ˆå¸Œè¡¨ä¸­æ’å…¥ä¸€ä¸ªæ•°
    void insert(int x)
    {
        int k = (x % N + N) % N;
        e[idx] = x;
        ne[idx] = h[k];
        h[k] = idx ++ ;
    }

    // åœ¨å“ˆå¸Œè¡¨ä¸­æŸ¥è¯¢æŸä¸ªæ•°æ˜¯å¦å­˜åœ¨
    bool find(int x)
    {
        int k = (x % N + N) % N;
        for (int i = h[k]; i != -1; i = ne[i])
            if (e[i] == x)
                return true;

        return false;
    }
(2) å¼€æ”¾å¯»å€æ³•
    int h[N];

    // å¦‚æœxåœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œè¿”å›xçš„ä¸‹æ ‡ï¼›å¦‚æœxä¸åœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œè¿”å›xåº”è¯¥æ’å…¥çš„ä½ç½®
    int find(int x)
    {
        int t = (x % N + N) % N;
        while (h[t] != null && h[t] != x)
        {
            t ++ ;
            if (t == N) t = 0;
        }
        return t;
    }
```
## å­—ç¬¦ä¸²å“ˆå¸Œ
```c
æ ¸å¿ƒæ€æƒ³ï¼šå°†å­—ç¬¦ä¸²çœ‹æˆPè¿›åˆ¶æ•°ï¼ŒPçš„ç»éªŒå€¼æ˜¯131æˆ–13331ï¼Œå–è¿™ä¸¤ä¸ªå€¼çš„å†²çªæ¦‚ç‡ä½
å°æŠ€å·§ï¼šå–æ¨¡çš„æ•°ç”¨2^64ï¼Œè¿™æ ·ç›´æ¥ç”¨unsigned long longå­˜å‚¨ï¼Œæº¢å‡ºçš„ç»“æœå°±æ˜¯å–æ¨¡çš„ç»“æœ

typedef unsigned long long ULL;
ULL h[N], p[N]; // h[k]å­˜å‚¨å­—ç¬¦ä¸²å‰kä¸ªå­—æ¯çš„å“ˆå¸Œå€¼, p[k]å­˜å‚¨ P^k mod 2^64

// åˆå§‹åŒ–
p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
    h[i] = h[i - 1] * P + str[i];
    p[i] = p[i - 1] * P;
}

// è®¡ç®—å­ä¸² str[l ~ r] çš„å“ˆå¸Œå€¼
ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}
```
## C++ STLç®€ä»‹
```c
vector, å˜é•¿æ•°ç»„ï¼Œå€å¢çš„æ€æƒ³
    size()  è¿”å›å…ƒç´ ä¸ªæ•°
    empty()  è¿”å›æ˜¯å¦ä¸ºç©º
    clear()  æ¸…ç©º
    front()/back()
    push_back()/pop_back()
    begin()/end()
    []
    æ”¯æŒæ¯”è¾ƒè¿ç®—ï¼ŒæŒ‰å­—å…¸åº

pair<int, int>
    first, ç¬¬ä¸€ä¸ªå…ƒç´ 
    second, ç¬¬äºŒä¸ªå…ƒç´ 
    æ”¯æŒæ¯”è¾ƒè¿ç®—ï¼Œä»¥firstä¸ºç¬¬ä¸€å…³é”®å­—ï¼Œä»¥secondä¸ºç¬¬äºŒå…³é”®å­—ï¼ˆå­—å…¸åºï¼‰

stringï¼Œå­—ç¬¦ä¸²
    size()/length()  è¿”å›å­—ç¬¦ä¸²é•¿åº¦
    empty()
    clear()
    substr(èµ·å§‹ä¸‹æ ‡ï¼Œ(å­ä¸²é•¿åº¦))  è¿”å›å­ä¸²
    c_str()  è¿”å›å­—ç¬¦ä¸²æ‰€åœ¨å­—ç¬¦æ•°ç»„çš„èµ·å§‹åœ°å€

queue, é˜Ÿåˆ—
    size()
    empty()
    push()  å‘é˜Ÿå°¾æ’å…¥ä¸€ä¸ªå…ƒç´ 
    front()  è¿”å›é˜Ÿå¤´å…ƒç´ 
    back()  è¿”å›é˜Ÿå°¾å…ƒç´ 
    pop()  å¼¹å‡ºé˜Ÿå¤´å…ƒç´ 

priority_queue, ä¼˜å…ˆé˜Ÿåˆ—ï¼Œé»˜è®¤æ˜¯å¤§æ ¹å †
    size()
    empty()
    push()  æ’å…¥ä¸€ä¸ªå…ƒç´ 
    top()  è¿”å›å †é¡¶å…ƒç´ 
    pop()  å¼¹å‡ºå †é¡¶å…ƒç´ 
    å®šä¹‰æˆå°æ ¹å †çš„æ–¹å¼ï¼špriority_queue<int, vector<int>, greater<int>> q;

stack, æ ˆ
    size()
    empty()
    push()  å‘æ ˆé¡¶æ’å…¥ä¸€ä¸ªå…ƒç´ 
    top()  è¿”å›æ ˆé¡¶å…ƒç´ 
    pop()  å¼¹å‡ºæ ˆé¡¶å…ƒç´ 

deque, åŒç«¯é˜Ÿåˆ—
    size()
    empty()
    clear()
    front()/back()
    push_back()/pop_back()
    push_front()/pop_front()
    begin()/end()
    []

set, map, multiset, multimap, åŸºäºå¹³è¡¡äºŒå‰æ ‘ï¼ˆçº¢é»‘æ ‘ï¼‰ï¼ŒåŠ¨æ€ç»´æŠ¤æœ‰åºåºåˆ—
    size()
    empty()
    clear()
    begin()/end()
    ++, -- è¿”å›å‰é©±å’Œåç»§ï¼Œæ—¶é—´å¤æ‚åº¦ O(logn)

    set/multiset
        insert()  æ’å…¥ä¸€ä¸ªæ•°
        find()  æŸ¥æ‰¾ä¸€ä¸ªæ•°
        count()  è¿”å›æŸä¸€ä¸ªæ•°çš„ä¸ªæ•°
        erase()
            (1) è¾“å…¥æ˜¯ä¸€ä¸ªæ•°xï¼Œåˆ é™¤æ‰€æœ‰x   O(k + logn)
            (2) è¾“å…¥ä¸€ä¸ªè¿­ä»£å™¨ï¼Œåˆ é™¤è¿™ä¸ªè¿­ä»£å™¨
        lower_bound()/upper_bound()
            lower_bound(x)  è¿”å›å¤§äºç­‰äºxçš„æœ€å°çš„æ•°çš„è¿­ä»£å™¨
            upper_bound(x)  è¿”å›å¤§äºxçš„æœ€å°çš„æ•°çš„è¿­ä»£å™¨
    map/multimap
        insert()  æ’å…¥çš„æ•°æ˜¯ä¸€ä¸ªpair
        erase()  è¾“å…¥çš„å‚æ•°æ˜¯pairæˆ–è€…è¿­ä»£å™¨
        find()
        []  æ³¨æ„multimapä¸æ”¯æŒæ­¤æ“ä½œã€‚ æ—¶é—´å¤æ‚åº¦æ˜¯ O(logn)
        lower_bound()/upper_bound()

unordered_set, unordered_map, unordered_multiset, unordered_multimap, å“ˆå¸Œè¡¨
    å’Œä¸Šé¢ç±»ä¼¼ï¼Œå¢åˆ æ”¹æŸ¥çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(1)
    ä¸æ”¯æŒ lower_bound()/upper_bound()ï¼Œ è¿­ä»£å™¨çš„++ï¼Œ--

bitset, åœ§ä½
    bitset<10000> s;
    ~, &, |, ^
    >>, <<
    ==, !=
    []

    count()  è¿”å›æœ‰å¤šå°‘ä¸ª1

    any()  åˆ¤æ–­æ˜¯å¦è‡³å°‘æœ‰ä¸€ä¸ª1
    none()  åˆ¤æ–­æ˜¯å¦å…¨ä¸º0

    set()  æŠŠæ‰€æœ‰ä½ç½®æˆ1
    set(k, v)  å°†ç¬¬kä½å˜æˆv
    reset()  æŠŠæ‰€æœ‰ä½å˜æˆ0
    flip()  ç­‰ä»·äº~
    flip(k) æŠŠç¬¬kä½å–å
```
# æœç´¢ä¸å›¾è®º
## æ ‘ä¸å›¾çš„å­˜å‚¨
æ ‘æ˜¯ä¸€ç§ç‰¹æ®Šçš„å›¾ï¼Œä¸å›¾çš„å­˜å‚¨æ–¹å¼ç›¸åŒã€‚
å¯¹äºæ— å‘å›¾ä¸­çš„è¾¹abï¼Œå­˜å‚¨ä¸¤æ¡æœ‰å‘è¾¹a->b, b->aã€‚
å› æ­¤æˆ‘ä»¬å¯ä»¥åªè€ƒè™‘æœ‰å‘å›¾çš„å­˜å‚¨ã€‚

(1) é‚»æ¥çŸ©é˜µï¼šg[a][b] å­˜å‚¨è¾¹a->b

(2) é‚»æ¥è¡¨ï¼š
```c
// å¯¹äºæ¯ä¸ªç‚¹kï¼Œå¼€ä¸€ä¸ªå•é“¾è¡¨ï¼Œå­˜å‚¨kæ‰€æœ‰å¯ä»¥èµ°åˆ°çš„ç‚¹ã€‚h[k]å­˜å‚¨è¿™ä¸ªå•é“¾è¡¨çš„å¤´ç»“ç‚¹
int h[N], e[N], ne[N], idx;

// æ·»åŠ ä¸€æ¡è¾¹a->b
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

// åˆå§‹åŒ–
idx = 0;
memset(h, -1, sizeof h);
```
## æ ‘ä¸å›¾çš„éå†
æ—¶é—´å¤æ‚åº¦ O(n+m), n è¡¨ç¤ºç‚¹æ•°ï¼Œm è¡¨ç¤ºè¾¹æ•°
(1) æ·±åº¦ä¼˜å…ˆéå†
```c
int dfs(int u)
{
    st[u] = true; // st[u] è¡¨ç¤ºç‚¹uå·²ç»è¢«éå†è¿‡

    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j]) dfs(j);
    }
}
```
(2) å®½åº¦ä¼˜å…ˆéå†
```c
queue<int> q;
st[1] = true; // è¡¨ç¤º1å·ç‚¹å·²ç»è¢«éå†è¿‡
q.push(1);

while (q.size())
{
    int t = q.front();
    q.pop();

    for (int i = h[t]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true; // è¡¨ç¤ºç‚¹jå·²ç»è¢«éå†è¿‡
            q.push(j);
        }
    }
}
```
## æ‹“æ‰‘æ’åº
æ—¶é—´å¤æ‚åº¦O(n+m), n è¡¨ç¤ºç‚¹æ•°ï¼Œm è¡¨ç¤ºè¾¹æ•°
```c
bool topsort()
{
    int hh = 0, tt = -1;

    // d[i] å­˜å‚¨ç‚¹içš„å…¥åº¦
    for (int i = 1; i <= n; i ++ )
        if (!d[i])
            q[ ++ tt] = i;

    while (hh <= tt)
    {
        int t = q[hh ++ ];

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (-- d[j] == 0)
                q[ ++ tt] = j;
        }
    }

    // å¦‚æœæ‰€æœ‰ç‚¹éƒ½å…¥é˜Ÿäº†ï¼Œè¯´æ˜å­˜åœ¨æ‹“æ‰‘åºåˆ—ï¼›å¦åˆ™ä¸å­˜åœ¨æ‹“æ‰‘åºåˆ—ã€‚
    return tt == n - 1;
}
```
## æœ´ç´ dijkstraç®—æ³•
æ—¶é—´å¤æ‚æ˜¯ O(n<sup>2</sup>+m), n è¡¨ç¤ºç‚¹æ•°ï¼Œm è¡¨ç¤ºè¾¹æ•°
```c
int g[N][N];  // å­˜å‚¨æ¯æ¡è¾¹
int dist[N];  // å­˜å‚¨1å·ç‚¹åˆ°æ¯ä¸ªç‚¹çš„æœ€çŸ­è·ç¦»
bool st[N];   // å­˜å‚¨æ¯ä¸ªç‚¹çš„æœ€çŸ­è·¯æ˜¯å¦å·²ç»ç¡®å®š

// æ±‚1å·ç‚¹åˆ°nå·ç‚¹çš„æœ€çŸ­è·¯ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™è¿”å›-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    for (int i = 0; i < n - 1; i ++ )
    {
        int t = -1;     // åœ¨è¿˜æœªç¡®å®šæœ€çŸ­è·¯çš„ç‚¹ä¸­ï¼Œå¯»æ‰¾è·ç¦»æœ€å°çš„ç‚¹
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        // ç”¨tæ›´æ–°å…¶ä»–ç‚¹çš„è·ç¦»
        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);

        st[t] = true;
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```
## å †ä¼˜åŒ–ç‰ˆdijkstra
æ—¶é—´å¤æ‚åº¦ O(mlogn), n è¡¨ç¤ºç‚¹æ•°ï¼Œm è¡¨ç¤ºè¾¹æ•°
```c
typedef pair<int, int> PII;

int n;      // ç‚¹çš„æ•°é‡
int h[N], w[N], e[N], ne[N], idx;       // é‚»æ¥è¡¨å­˜å‚¨æ‰€æœ‰è¾¹
int dist[N];        // å­˜å‚¨æ‰€æœ‰ç‚¹åˆ°1å·ç‚¹çš„è·ç¦»
bool st[N];     // å­˜å‚¨æ¯ä¸ªç‚¹çš„æœ€çŸ­è·ç¦»æ˜¯å¦å·²ç¡®å®š

// æ±‚1å·ç‚¹åˆ°nå·ç‚¹çš„æœ€çŸ­è·ç¦»ï¼Œå¦‚æœä¸å­˜åœ¨ï¼Œåˆ™è¿”å›-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});      // firstå­˜å‚¨è·ç¦»ï¼Œsecondå­˜å‚¨èŠ‚ç‚¹ç¼–å·

    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();

        int ver = t.second, distance = t.first;

        if (st[ver]) continue;
        st[ver] = true;

        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```
## Bellman-Fordç®—æ³•
æ—¶é—´å¤æ‚åº¦ O(nm), n è¡¨ç¤ºç‚¹æ•°ï¼Œm è¡¨ç¤ºè¾¹æ•°
æ³¨æ„åœ¨æ¨¡æ¿é¢˜ä¸­éœ€è¦å¯¹ä¸‹é¢çš„æ¨¡æ¿ç¨ä½œä¿®æ”¹ï¼ŒåŠ ä¸Šå¤‡ä»½æ•°ç»„ï¼Œè¯¦æƒ…è§æ¨¡æ¿é¢˜ã€‚
```c
int n, m;       // nè¡¨ç¤ºç‚¹æ•°ï¼Œmè¡¨ç¤ºè¾¹æ•°
int dist[N];        // dist[x]å­˜å‚¨1åˆ°xçš„æœ€çŸ­è·¯è·ç¦»

struct Edge     // è¾¹ï¼Œaè¡¨ç¤ºå‡ºç‚¹ï¼Œbè¡¨ç¤ºå…¥ç‚¹ï¼Œwè¡¨ç¤ºè¾¹çš„æƒé‡
{
    int a, b, w;
}edges[M];

// æ±‚1åˆ°nçš„æœ€çŸ­è·¯è·ç¦»ï¼Œå¦‚æœæ— æ³•ä»1èµ°åˆ°nï¼Œåˆ™è¿”å›-1ã€‚
int bellman_ford()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    // å¦‚æœç¬¬næ¬¡è¿­ä»£ä»ç„¶ä¼šæ¾å¼›ä¸‰è§’ä¸ç­‰å¼ï¼Œå°±è¯´æ˜å­˜åœ¨ä¸€æ¡é•¿åº¦æ˜¯n+1çš„æœ€çŸ­è·¯å¾„ï¼Œç”±æŠ½å±‰åŸç†ï¼Œè·¯å¾„ä¸­è‡³å°‘å­˜åœ¨ä¸¤ä¸ªç›¸åŒçš„ç‚¹ï¼Œè¯´æ˜å›¾ä¸­å­˜åœ¨è´Ÿæƒå›è·¯ã€‚
    for (int i = 0; i < n; i ++ )
    {
        for (int j = 0; j < m; j ++ )
        {
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;
            if (dist[b] > dist[a] + w)
                dist[b] = dist[a] + w;
        }
    }

    if (dist[n] > 0x3f3f3f3f / 2) return -1;
    return dist[n];
}
```
## spfa ç®—æ³•ï¼ˆé˜Ÿåˆ—ä¼˜åŒ–çš„Bellman-Fordç®—æ³•ï¼‰
æ—¶é—´å¤æ‚åº¦ å¹³å‡æƒ…å†µä¸‹ O(m)ï¼Œæœ€åæƒ…å†µä¸‹ O(nm), n è¡¨ç¤ºç‚¹æ•°ï¼Œm è¡¨ç¤ºè¾¹æ•°
```c
int n;      // æ€»ç‚¹æ•°
int h[N], w[N], e[N], ne[N], idx;       // é‚»æ¥è¡¨å­˜å‚¨æ‰€æœ‰è¾¹
int dist[N];        // å­˜å‚¨æ¯ä¸ªç‚¹åˆ°1å·ç‚¹çš„æœ€çŸ­è·ç¦»
bool st[N];     // å­˜å‚¨æ¯ä¸ªç‚¹æ˜¯å¦åœ¨é˜Ÿåˆ—ä¸­

// æ±‚1å·ç‚¹åˆ°nå·ç‚¹çš„æœ€çŸ­è·¯è·ç¦»ï¼Œå¦‚æœä»1å·ç‚¹æ— æ³•èµ°åˆ°nå·ç‚¹åˆ™è¿”å›-1
int spfa()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    queue<int> q;
    q.push(1);
    st[1] = true;

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])     // å¦‚æœé˜Ÿåˆ—ä¸­å·²å­˜åœ¨jï¼Œåˆ™ä¸éœ€è¦å°†jé‡å¤æ’å…¥
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```
## spfaåˆ¤æ–­å›¾ä¸­æ˜¯å¦å­˜åœ¨è´Ÿç¯ 

 æ—¶é—´å¤æ‚åº¦æ˜¯ $O(nm)$, $n$ è¡¨ç¤ºç‚¹æ•°ï¼Œ$m$ è¡¨ç¤ºè¾¹æ•°

```c
int n;      // æ€»ç‚¹æ•°
int h[N], w[N], e[N], ne[N], idx;       // é‚»æ¥è¡¨å­˜å‚¨æ‰€æœ‰è¾¹
int dist[N], cnt[N];        // dist[x]å­˜å‚¨1å·ç‚¹åˆ°xçš„æœ€çŸ­è·ç¦»ï¼Œcnt[x]å­˜å‚¨1åˆ°xçš„æœ€çŸ­è·¯ä¸­ç»è¿‡çš„ç‚¹æ•°
bool st[N];     // å­˜å‚¨æ¯ä¸ªç‚¹æ˜¯å¦åœ¨é˜Ÿåˆ—ä¸­

// å¦‚æœå­˜åœ¨è´Ÿç¯ï¼Œåˆ™è¿”å›trueï¼Œå¦åˆ™è¿”å›falseã€‚
bool spfa()
{
    // ä¸éœ€è¦åˆå§‹åŒ–distæ•°ç»„
    // åŸç†ï¼šå¦‚æœæŸæ¡æœ€çŸ­è·¯å¾„ä¸Šæœ‰nä¸ªç‚¹ï¼ˆé™¤äº†è‡ªå·±ï¼‰ï¼Œé‚£ä¹ˆåŠ ä¸Šè‡ªå·±ä¹‹åä¸€å…±æœ‰n+1ä¸ªç‚¹ï¼Œç”±æŠ½å±‰åŸç†ä¸€å®šæœ‰ä¸¤ä¸ªç‚¹ç›¸åŒï¼Œæ‰€ä»¥å­˜åœ¨ç¯ã€‚

    queue<int> q;
    for (int i = 1; i <= n; i ++ )
    {
        q.push(i);
        st[i] = true;
    }

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if (cnt[j] >= n) return true;       // å¦‚æœä»1å·ç‚¹åˆ°xçš„æœ€çŸ­è·¯ä¸­åŒ…å«è‡³å°‘nä¸ªç‚¹ï¼ˆä¸åŒ…æ‹¬è‡ªå·±ï¼‰ï¼Œåˆ™è¯´æ˜å­˜åœ¨ç¯
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    return false;
}
```

___

## floydç®—æ³•

 æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n^3)$, $n$ è¡¨ç¤ºç‚¹æ•°

```c
åˆå§‹åŒ–ï¼š
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            if (i == j) d[i][j] = 0;
            else d[i][j] = INF;

// ç®—æ³•ç»“æŸåï¼Œd[a][b]è¡¨ç¤ºaåˆ°bçš„æœ€çŸ­è·ç¦»
void floyd()
{
    for (int k = 1; k <= n; k ++ )
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}
```

___

## æœ´ç´ ç‰ˆprimç®—æ³•

 æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n^2+m)$, $n$ è¡¨ç¤ºç‚¹æ•°ï¼Œ$m$ è¡¨ç¤ºè¾¹æ•°

```c
int n;      // nè¡¨ç¤ºç‚¹æ•°
int g[N][N];        // é‚»æ¥çŸ©é˜µï¼Œå­˜å‚¨æ‰€æœ‰è¾¹
int dist[N];        // å­˜å‚¨å…¶ä»–ç‚¹åˆ°å½“å‰æœ€å°ç”Ÿæˆæ ‘çš„è·ç¦»
bool st[N];     // å­˜å‚¨æ¯ä¸ªç‚¹æ˜¯å¦å·²ç»åœ¨ç”Ÿæˆæ ‘ä¸­


// å¦‚æœå›¾ä¸è¿é€šï¼Œåˆ™è¿”å›INF(å€¼æ˜¯0x3f3f3f3f), å¦åˆ™è¿”å›æœ€å°ç”Ÿæˆæ ‘çš„æ ‘è¾¹æƒé‡ä¹‹å’Œ
int prim()
{
    memset(dist, 0x3f, sizeof dist);

    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        if (i && dist[t] == INF) return INF;

        if (i) res += dist[t];
        st[t] = true;

        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
    }

    return res;
}
```

___

## Kruskalç®—æ³•

 æ—¶é—´å¤æ‚åº¦æ˜¯ $O(mlogm)$, $n$ è¡¨ç¤ºç‚¹æ•°ï¼Œ$m$ è¡¨ç¤ºè¾¹æ•°

```c
int n, m;       // næ˜¯ç‚¹æ•°ï¼Œmæ˜¯è¾¹æ•°
int p[N];       // å¹¶æŸ¥é›†çš„çˆ¶èŠ‚ç‚¹æ•°ç»„

struct Edge     // å­˜å‚¨è¾¹
{
    int a, b, w;

    bool operator< (const Edge &W)const
    {
        return w < W.w;
    }
}edges[M];

int find(int x)     // å¹¶æŸ¥é›†æ ¸å¿ƒæ“ä½œ
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int kruskal()
{
    sort(edges, edges + m);

    for (int i = 1; i <= n; i ++ ) p[i] = i;    // åˆå§‹åŒ–å¹¶æŸ¥é›†

    int res = 0, cnt = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;

        a = find(a), b = find(b);
        if (a != b)     // å¦‚æœä¸¤ä¸ªè¿é€šå—ä¸è¿é€šï¼Œåˆ™å°†è¿™ä¸¤ä¸ªè¿é€šå—åˆå¹¶
        {
            p[a] = b;
            res += w;
            cnt ++ ;
        }
    }

    if (cnt < n - 1) return INF;
    return res;
}
```

___

## æŸ“è‰²æ³•åˆ¤åˆ«äºŒåˆ†å›¾

 æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n+m)$, $n$ è¡¨ç¤ºç‚¹æ•°ï¼Œ$m$ è¡¨ç¤ºè¾¹æ•°

```c
int n;      // nè¡¨ç¤ºç‚¹æ•°
int h[N], e[M], ne[M], idx;     // é‚»æ¥è¡¨å­˜å‚¨å›¾
int color[N];       // è¡¨ç¤ºæ¯ä¸ªç‚¹çš„é¢œè‰²ï¼Œ-1è¡¨ç¤ºæœªæŸ“è‰²ï¼Œ0è¡¨ç¤ºç™½è‰²ï¼Œ1è¡¨ç¤ºé»‘è‰²

// å‚æ•°ï¼šuè¡¨ç¤ºå½“å‰èŠ‚ç‚¹ï¼Œcè¡¨ç¤ºå½“å‰ç‚¹çš„é¢œè‰²
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }

    return true;
}

bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```

___

## åŒˆç‰™åˆ©ç®—æ³•

 æ—¶é—´å¤æ‚åº¦æ˜¯ $O(nm)$, $n$ è¡¨ç¤ºç‚¹æ•°ï¼Œ$m$ è¡¨ç¤ºè¾¹æ•°

```c
int n1, n2;     // n1è¡¨ç¤ºç¬¬ä¸€ä¸ªé›†åˆä¸­çš„ç‚¹æ•°ï¼Œn2è¡¨ç¤ºç¬¬äºŒä¸ªé›†åˆä¸­çš„ç‚¹æ•°
int h[N], e[M], ne[M], idx;     // é‚»æ¥è¡¨å­˜å‚¨æ‰€æœ‰è¾¹ï¼ŒåŒˆç‰™åˆ©ç®—æ³•ä¸­åªä¼šç”¨åˆ°ä»ç¬¬ä¸€ä¸ªé›†åˆæŒ‡å‘ç¬¬äºŒä¸ªé›†åˆçš„è¾¹ï¼Œæ‰€ä»¥è¿™é‡Œåªç”¨å­˜ä¸€ä¸ªæ–¹å‘çš„è¾¹
int match[N];       // å­˜å‚¨ç¬¬äºŒä¸ªé›†åˆä¸­çš„æ¯ä¸ªç‚¹å½“å‰åŒ¹é…çš„ç¬¬ä¸€ä¸ªé›†åˆä¸­çš„ç‚¹æ˜¯å“ªä¸ª
bool st[N];     // è¡¨ç¤ºç¬¬äºŒä¸ªé›†åˆä¸­çš„æ¯ä¸ªç‚¹æ˜¯å¦å·²ç»è¢«éå†è¿‡

bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }

    return false;
}

// æ±‚æœ€å¤§åŒ¹é…æ•°ï¼Œä¾æ¬¡æšä¸¾ç¬¬ä¸€ä¸ªé›†åˆä¸­çš„æ¯ä¸ªç‚¹èƒ½å¦åŒ¹é…ç¬¬äºŒä¸ªé›†åˆä¸­çš„ç‚¹
int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```


# æ•°å­¦çŸ¥è¯†

## è¯•é™¤æ³•åˆ¤å®šè´¨æ•°

```c
bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
            return false;
    return true;
}
```

___

## è¯•é™¤æ³•åˆ†è§£è´¨å› æ•°

```c
void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            cout << i << ' ' << s << endl;
        }
    if (x > 1) cout << x << ' ' << 1 << endl;
    cout << endl;
}
```

___

## æœ´ç´ ç­›æ³•æ±‚ç´ æ•°

```c
int primes[N], cnt;     // primes[]å­˜å‚¨æ‰€æœ‰ç´ æ•°
bool st[N];         // st[x]å­˜å‚¨xæ˜¯å¦è¢«ç­›æ‰

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (st[i]) continue;
        primes[cnt ++ ] = i;
        for (int j = i + i; j <= n; j += i)
            st[j] = true;
    }
}
```

___

## çº¿æ€§ç­›æ³•æ±‚ç´ æ•°

```c
int primes[N], cnt;     // primes[]å­˜å‚¨æ‰€æœ‰ç´ æ•°
bool st[N];         // st[x]å­˜å‚¨xæ˜¯å¦è¢«ç­›æ‰

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
```

___

## è¯•é™¤æ³•æ±‚æ‰€æœ‰çº¦æ•°

```c
vector<int> get_divisors(int x)
{
    vector<int> res;
    for (int i = 1; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);
        }
    sort(res.begin(), res.end());
    return res;
}
```

___

## çº¦æ•°ä¸ªæ•°å’Œçº¦æ•°ä¹‹å’Œ

```c
å¦‚æœ N = p1^c1 * p2^c2 * ... *pk^ck
çº¦æ•°ä¸ªæ•°ï¼š (c1 + 1) * (c2 + 1) * ... * (ck + 1)
çº¦æ•°ä¹‹å’Œï¼š (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck)
```

___

## æ¬§å‡ é‡Œå¾—ç®—æ³•

```c
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
```

___

## æ±‚æ¬§æ‹‰å‡½æ•°

```c
int phi(int x)
{
    int res = x;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res = res / i * (i - 1);
            while (x % i == 0) x /= i;
        }
    if (x > 1) res = res / x * (x - 1);

    return res;
}
```

___

## ç­›æ³•æ±‚æ¬§æ‹‰å‡½æ•°

```c
int primes[N], cnt;     // primes[]å­˜å‚¨æ‰€æœ‰ç´ æ•°
int euler[N];           // å­˜å‚¨æ¯ä¸ªæ•°çš„æ¬§æ‹‰å‡½æ•°
bool st[N];         // st[x]å­˜å‚¨xæ˜¯å¦è¢«ç­›æ‰


void get_eulers(int n)
{
    euler[1] = 1;
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            euler[i] = i - 1;
        }
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            int t = primes[j] * i;
            st[t] = true;
            if (i % primes[j] == 0)
            {
                euler[t] = euler[i] * primes[j];
                break;
            }
            euler[t] = euler[i] * (primes[j] - 1);
        }
    }
}
```

___

## å¿«é€Ÿå¹‚

```c
æ±‚ m^k mod pï¼Œæ—¶é—´å¤æ‚åº¦ O(logk)ã€‚

int qmi(int m, int k, int p)
{
    int res = 1 % p, t = m;
    while (k)
    {
        if (k&1) res = res * t % p;
        t = t * t % p;
        k >>= 1;
    }
    return res;
}
```

___

## æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•

```c
// æ±‚x, yï¼Œä½¿å¾—ax + by = gcd(a, b)
int exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        x = 1; y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= (a/b) * x;
    return d;
}
```

___

## é«˜æ–¯æ¶ˆå…ƒ

```c
// a[N][N]æ˜¯å¢å¹¿çŸ©é˜µ
int gauss()
{
    int c, r;
    for (c = 0, r = 0; c < n; c ++ )
    {
        int t = r;
        for (int i = r; i < n; i ++ )   // æ‰¾åˆ°ç»å¯¹å€¼æœ€å¤§çš„è¡Œ
            if (fabs(a[i][c]) > fabs(a[t][c]))
                t = i;

        if (fabs(a[t][c]) < eps) continue;

        for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);      // å°†ç»å¯¹å€¼æœ€å¤§çš„è¡Œæ¢åˆ°æœ€é¡¶ç«¯
        for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];      // å°†å½“å‰è¡Œçš„é¦–ä½å˜æˆ1
        for (int i = r + 1; i < n; i ++ )       // ç”¨å½“å‰è¡Œå°†ä¸‹é¢æ‰€æœ‰çš„åˆ—æ¶ˆæˆ0
            if (fabs(a[i][c]) > eps)
                for (int j = n; j >= c; j -- )
                    a[i][j] -= a[r][j] * a[i][c];

        r ++ ;
    }

    if (r < n)
    {
        for (int i = r; i < n; i ++ )
            if (fabs(a[i][n]) > eps)
                return 2; // æ— è§£
        return 1; // æœ‰æ— ç©·å¤šç»„è§£
    }

    for (int i = n - 1; i >= 0; i -- )
        for (int j = i + 1; j < n; j ++ )
            a[i][n] -= a[i][j] * a[j][n];

    return 0; // æœ‰å”¯ä¸€è§£
}
```

___

## é€’æ¨æ³•æ±‚ç»„åˆæ•°

```c
// c[a][b] è¡¨ç¤ºä»aä¸ªè‹¹æœä¸­é€‰bä¸ªçš„æ–¹æ¡ˆæ•°
for (int i = 0; i < N; i ++ )
    for (int j = 0; j <= i; j ++ )
        if (!j) c[i][j] = 1;
        else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
```

___

## é€šè¿‡é¢„å¤„ç†é€†å…ƒçš„æ–¹å¼æ±‚ç»„åˆæ•°

```c
é¦–å…ˆé¢„å¤„ç†å‡ºæ‰€æœ‰é˜¶ä¹˜å–æ¨¡çš„ä½™æ•°fact[N]ï¼Œä»¥åŠæ‰€æœ‰é˜¶ä¹˜å–æ¨¡çš„é€†å…ƒinfact[N]
å¦‚æœå–æ¨¡çš„æ•°æ˜¯è´¨æ•°ï¼Œå¯ä»¥ç”¨è´¹é©¬å°å®šç†æ±‚é€†å…ƒ
int qmi(int a, int k, int p)    // å¿«é€Ÿå¹‚æ¨¡æ¿
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}

// é¢„å¤„ç†é˜¶ä¹˜çš„ä½™æ•°å’Œé˜¶ä¹˜é€†å…ƒçš„ä½™æ•°
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
    fact[i] = (LL)fact[i - 1] * i % mod;
    infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```

___

## Lucaså®šç†

```c
è‹¥pæ˜¯è´¨æ•°ï¼Œåˆ™å¯¹äºä»»æ„æ•´æ•° 1 <= m <= nï¼Œæœ‰ï¼š
    C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p)

int qmi(int a, int k, int p)  // å¿«é€Ÿå¹‚æ¨¡æ¿
{
    int res = 1 % p;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}

int C(int a, int b, int p)  // é€šè¿‡å®šç†æ±‚ç»„åˆæ•°C(a, b)
{
    if (a < b) return 0;

    LL x = 1, y = 1;  // xæ˜¯åˆ†å­ï¼Œyæ˜¯åˆ†æ¯
    for (int i = a, j = 1; j <= b; i --, j ++ )
    {
        x = (LL)x * i % p;
        y = (LL) y * j % p;
    }

    return x * (LL)qmi(y, p - 2, p) % p;
}

int lucas(LL a, LL b, int p)
{
    if (a < p && b < p) return C(a, b, p);
    return (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;
}
```

___

## åˆ†è§£è´¨å› æ•°æ³•æ±‚ç»„åˆæ•°

```c
å½“æˆ‘ä»¬éœ€è¦æ±‚å‡ºç»„åˆæ•°çš„çœŸå®å€¼ï¼Œè€Œéå¯¹æŸä¸ªæ•°çš„ä½™æ•°æ—¶ï¼Œåˆ†è§£è´¨å› æ•°çš„æ–¹å¼æ¯”è¾ƒå¥½ç”¨ï¼š
    1. ç­›æ³•æ±‚å‡ºèŒƒå›´å†…çš„æ‰€æœ‰è´¨æ•°
    2. é€šè¿‡ C(a, b) = a! / b! / (a - b)! è¿™ä¸ªå…¬å¼æ±‚å‡ºæ¯ä¸ªè´¨å› å­çš„æ¬¡æ•°ã€‚ n! ä¸­pçš„æ¬¡æ•°æ˜¯ n / p + n / p^2 + n / p^3 + ...
    3. ç”¨é«˜ç²¾åº¦ä¹˜æ³•å°†æ‰€æœ‰è´¨å› å­ç›¸ä¹˜

int primes[N], cnt;     // å­˜å‚¨æ‰€æœ‰è´¨æ•°
int sum[N];     // å­˜å‚¨æ¯ä¸ªè´¨æ•°çš„æ¬¡æ•°
bool st[N];     // å­˜å‚¨æ¯ä¸ªæ•°æ˜¯å¦å·²è¢«ç­›æ‰


void get_primes(int n)      // çº¿æ€§ç­›æ³•æ±‚ç´ æ•°
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}


int get(int n, int p)       // æ±‚nï¼ä¸­çš„æ¬¡æ•°
{
    int res = 0;
    while (n)
    {
        res += n / p;
        n /= p;
    }
    return res;
}


vector<int> mul(vector<int> a, int b)       // é«˜ç²¾åº¦ä¹˜ä½ç²¾åº¦æ¨¡æ¿
{
    vector<int> c;
    int t = 0;
    for (int i = 0; i < a.size(); i ++ )
    {
        t += a[i] * b;
        c.push_back(t % 10);
        t /= 10;
    }

    while (t)
    {
        c.push_back(t % 10);
        t /= 10;
    }

    return c;
}

get_primes(a);  // é¢„å¤„ç†èŒƒå›´å†…çš„æ‰€æœ‰è´¨æ•°

for (int i = 0; i < cnt; i ++ )     // æ±‚æ¯ä¸ªè´¨å› æ•°çš„æ¬¡æ•°
{
    int p = primes[i];
    sum[i] = get(a, p) - get(b, p) - get(a - b, p);
}

vector<int> res;
res.push_back(1);

for (int i = 0; i < cnt; i ++ )     // ç”¨é«˜ç²¾åº¦ä¹˜æ³•å°†æ‰€æœ‰è´¨å› å­ç›¸ä¹˜
    for (int j = 0; j < sum[i]; j ++ )
        res = mul(res, primes[i]);

```

___

## å¡ç‰¹å…°æ•°

```c
ç»™å®šnä¸ª0å’Œnä¸ª1ï¼Œå®ƒä»¬æŒ‰ç…§æŸç§é¡ºåºæ’æˆé•¿åº¦ä¸º2nçš„åºåˆ—ï¼Œæ»¡è¶³ä»»æ„å‰ç¼€ä¸­0çš„ä¸ªæ•°éƒ½ä¸å°‘äº1çš„ä¸ªæ•°çš„åºåˆ—çš„æ•°é‡ä¸ºï¼š Cat(n) = C(2n, n) / (n + 1)
```

___

## NIMæ¸¸æˆ

ç»™å®šNå †ç‰©å“ï¼Œç¬¬iå †ç‰©å“æœ‰Aiä¸ªã€‚ä¸¤åç©å®¶è½®æµè¡ŒåŠ¨ï¼Œæ¯æ¬¡å¯ä»¥ä»»é€‰ä¸€å †ï¼Œå–èµ°ä»»æ„å¤šä¸ªç‰©å“ï¼Œå¯æŠŠä¸€å †å–å…‰ï¼Œä½†ä¸èƒ½ä¸å–ã€‚å–èµ°æœ€åä¸€ä»¶ç‰©å“è€…è·èƒœã€‚ä¸¤äººéƒ½é‡‡å–æœ€ä¼˜ç­–ç•¥ï¼Œé—®å…ˆæ‰‹æ˜¯å¦å¿…èƒœã€‚

æˆ‘ä»¬æŠŠè¿™ç§æ¸¸æˆç§°ä¸ºNIMåšå¼ˆã€‚æŠŠæ¸¸æˆè¿‡ç¨‹ä¸­é¢ä¸´çš„çŠ¶æ€ç§°ä¸ºå±€é¢ã€‚æ•´å±€æ¸¸æˆç¬¬ä¸€ä¸ªè¡ŒåŠ¨çš„ç§°ä¸ºå…ˆæ‰‹ï¼Œç¬¬äºŒä¸ªè¡ŒåŠ¨çš„ç§°ä¸ºåæ‰‹ã€‚è‹¥åœ¨æŸä¸€å±€é¢ä¸‹æ— è®ºé‡‡å–ä½•ç§è¡ŒåŠ¨ï¼Œéƒ½ä¼šè¾“æ‰æ¸¸æˆï¼Œåˆ™ç§°è¯¥å±€é¢å¿…è´¥ã€‚  
æ‰€è°“é‡‡å–æœ€ä¼˜ç­–ç•¥æ˜¯æŒ‡ï¼Œè‹¥åœ¨æŸä¸€å±€é¢ä¸‹å­˜åœ¨æŸç§è¡ŒåŠ¨ï¼Œä½¿å¾—è¡ŒåŠ¨åå¯¹é¢é¢ä¸´å¿…è´¥å±€é¢ï¼Œåˆ™ä¼˜å…ˆé‡‡å–è¯¥è¡ŒåŠ¨ã€‚åŒæ—¶ï¼Œè¿™æ ·çš„å±€é¢è¢«ç§°ä¸ºå¿…èƒœã€‚æˆ‘ä»¬è®¨è®ºçš„åšå¼ˆé—®é¢˜ä¸€èˆ¬éƒ½åªè€ƒè™‘ç†æƒ³æƒ…å†µï¼Œå³ä¸¤äººå‡æ— å¤±è¯¯ï¼Œéƒ½é‡‡å–æœ€ä¼˜ç­–ç•¥è¡ŒåŠ¨æ—¶æ¸¸æˆçš„ç»“æœã€‚  
NIMåšå¼ˆä¸å­˜åœ¨å¹³å±€ï¼Œåªæœ‰å…ˆæ‰‹å¿…èƒœå’Œå…ˆæ‰‹å¿…è´¥ä¸¤ç§æƒ…å†µã€‚

å®šç†ï¼š NIMåšå¼ˆå…ˆæ‰‹å¿…èƒœï¼Œå½“ä¸”ä»…å½“ A1 ^ A2 ^ â€¦ ^ An != 0

___

## å…¬å¹³ç»„åˆæ¸¸æˆICG

è‹¥ä¸€ä¸ªæ¸¸æˆæ»¡è¶³ï¼š

1.  ç”±ä¸¤åç©å®¶äº¤æ›¿è¡ŒåŠ¨ï¼›
2.  åœ¨æ¸¸æˆè¿›ç¨‹çš„ä»»æ„æ—¶åˆ»ï¼Œå¯ä»¥æ‰§è¡Œçš„åˆæ³•è¡ŒåŠ¨ä¸è½®åˆ°å“ªåç©å®¶æ— å…³ï¼›
3.  ä¸èƒ½è¡ŒåŠ¨çš„ç©å®¶åˆ¤è´Ÿï¼›

åˆ™ç§°è¯¥æ¸¸æˆä¸ºä¸€ä¸ªå…¬å¹³ç»„åˆæ¸¸æˆã€‚  
NIMåšå¼ˆå±äºå…¬å¹³ç»„åˆæ¸¸æˆï¼Œä½†åŸå»ºçš„æ£‹ç±»æ¸¸æˆï¼Œæ¯”å¦‚å›´æ£‹ï¼Œå°±ä¸æ˜¯å…¬å¹³ç»„åˆæ¸¸æˆã€‚å› ä¸ºå›´æ£‹äº¤æˆ˜åŒæ–¹åˆ†åˆ«åªèƒ½è½é»‘å­å’Œç™½å­ï¼Œèƒœè´Ÿåˆ¤å®šä¹Ÿæ¯”è¾ƒå¤æ‚ï¼Œä¸æ»¡è¶³æ¡ä»¶2å’Œæ¡ä»¶3ã€‚

___

## æœ‰å‘å›¾æ¸¸æˆ

ç»™å®šä¸€ä¸ªæœ‰å‘æ— ç¯å›¾ï¼Œå›¾ä¸­æœ‰ä¸€ä¸ªå”¯ä¸€çš„èµ·ç‚¹ï¼Œåœ¨èµ·ç‚¹ä¸Šæ”¾æœ‰ä¸€æšæ£‹å­ã€‚ä¸¤åç©å®¶äº¤æ›¿åœ°æŠŠè¿™æšæ£‹å­æ²¿æœ‰å‘è¾¹è¿›è¡Œç§»åŠ¨ï¼Œæ¯æ¬¡å¯ä»¥ç§»åŠ¨ä¸€æ­¥ï¼Œæ— æ³•ç§»åŠ¨è€…åˆ¤è´Ÿã€‚è¯¥æ¸¸æˆè¢«ç§°ä¸ºæœ‰å‘å›¾æ¸¸æˆã€‚  
ä»»ä½•ä¸€ä¸ªå…¬å¹³ç»„åˆæ¸¸æˆéƒ½å¯ä»¥è½¬åŒ–ä¸ºæœ‰å‘å›¾æ¸¸æˆã€‚å…·ä½“æ–¹æ³•æ˜¯ï¼ŒæŠŠæ¯ä¸ªå±€é¢çœ‹æˆå›¾ä¸­çš„ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¹¶ä¸”ä»æ¯ä¸ªå±€é¢å‘æ²¿ç€åˆæ³•è¡ŒåŠ¨èƒ½å¤Ÿåˆ°è¾¾çš„ä¸‹ä¸€ä¸ªå±€é¢è¿æœ‰å‘è¾¹ã€‚

___

## Mexè¿ç®—

è®¾Sè¡¨ç¤ºä¸€ä¸ªéè´Ÿæ•´æ•°é›†åˆã€‚å®šä¹‰mex(S)ä¸ºæ±‚å‡ºä¸å±äºé›†åˆSçš„æœ€å°éè´Ÿæ•´æ•°çš„è¿ç®—ï¼Œå³ï¼š  
mex(S) = min{x}, xå±äºè‡ªç„¶æ•°ï¼Œä¸”xä¸å±äºS

___

## SGå‡½æ•°

åœ¨æœ‰å‘å›¾æ¸¸æˆä¸­ï¼Œå¯¹äºæ¯ä¸ªèŠ‚ç‚¹xï¼Œè®¾ä»xå‡ºå‘å…±æœ‰kæ¡æœ‰å‘è¾¹ï¼Œåˆ†åˆ«åˆ°è¾¾èŠ‚ç‚¹y1, y2, â€¦, ykï¼Œå®šä¹‰SG(x)ä¸ºxçš„åç»§èŠ‚ç‚¹y1, y2, â€¦, yk çš„SGå‡½æ•°å€¼æ„æˆçš„é›†åˆå†æ‰§è¡Œmex(S)è¿ç®—çš„ç»“æœï¼Œå³ï¼š  
SG(x) = mex({SG(y1), SG(y2), â€¦, SG(yk)})  
ç‰¹åˆ«åœ°ï¼Œæ•´ä¸ªæœ‰å‘å›¾æ¸¸æˆGçš„SGå‡½æ•°å€¼è¢«å®šä¹‰ä¸ºæœ‰å‘å›¾æ¸¸æˆèµ·ç‚¹sçš„SGå‡½æ•°å€¼ï¼Œå³SG(G) = SG(s)ã€‚

___

## æœ‰å‘å›¾æ¸¸æˆçš„å’Œ

è®¾G1, G2, â€¦, Gm æ˜¯mä¸ªæœ‰å‘å›¾æ¸¸æˆã€‚å®šä¹‰æœ‰å‘å›¾æ¸¸æˆGï¼Œå®ƒçš„è¡ŒåŠ¨è§„åˆ™æ˜¯ä»»é€‰æŸä¸ªæœ‰å‘å›¾æ¸¸æˆGiï¼Œå¹¶åœ¨Giä¸Šè¡ŒåŠ¨ä¸€æ­¥ã€‚Gè¢«ç§°ä¸ºæœ‰å‘å›¾æ¸¸æˆG1, G2, â€¦, Gmçš„å’Œã€‚  
æœ‰å‘å›¾æ¸¸æˆçš„å’Œçš„SGå‡½æ•°å€¼ç­‰äºå®ƒåŒ…å«çš„å„ä¸ªå­æ¸¸æˆSGå‡½æ•°å€¼çš„å¼‚æˆ–å’Œï¼Œå³ï¼š  
SG(G) = SG(G1) ^ SG(G2) ^ â€¦ ^ SG(Gm)

___

## å®šç†

æœ‰å‘å›¾æ¸¸æˆçš„æŸä¸ªå±€é¢å¿…èƒœï¼Œå½“ä¸”ä»…å½“è¯¥å±€é¢å¯¹åº”èŠ‚ç‚¹çš„SGå‡½æ•°å€¼å¤§äº0ã€‚  
æœ‰å‘å›¾æ¸¸æˆçš„æŸä¸ªå±€é¢å¿…è´¥ï¼Œå½“ä¸”ä»…å½“è¯¥å±€é¢å¯¹åº”èŠ‚ç‚¹çš„SGå‡½æ•°å€¼ç­‰äº0ã€‚


---
# æ€»ç»“
ğŸ‹ ğŸ¬ ğŸ¶ ğŸ³ ğŸ° ğŸ¦€â˜ï¸ â­ ğŸ‘‰ ğŸ‘€

æ€»ä¹‹ï¼ŒæŒæ¡å¥½è“æ¡¥æ¯ç®—æ³•æ¨¡æ¿å¯¹äºæé«˜æˆ‘ä»¬çš„ç®—æ³•å†™é¢˜é€Ÿåº¦ã€æ‹“å®½æˆ‘ä»¬çš„æ€ç»´æ–¹å¼éƒ½å…·æœ‰é‡è¦çš„æ„ä¹‰ã€‚å¸Œæœ›æœ¬æ–‡ä»‹ç»çš„ä¸€äº›å¸¸è§ç®—æ³•æ¨¡æ¿å’Œå®ä¾‹èƒ½å¤Ÿä¸ºè¯»è€…æä¾›ä¸€äº›å¯å‘å’Œå¸®åŠ©ï¼Œè®©æˆ‘ä»¬åœ¨ç¼–ç¨‹ç«èµ›ä¸­å–å¾—æ›´å¥½çš„æˆç»©ï¼

å¦‚æœä½ å¯¹è¿™ç¯‡æ–‡ç« æ„Ÿå…´è¶£ï¼Œæ¬¢è¿åœ¨è¯„è®ºåŒºç•™è¨€ï¼Œåˆ†äº«ä½ çš„æƒ³æ³•å’Œå»ºè®®ã€‚å¦‚æœä½ å–œæ¬¢æˆ‘çš„åšå®¢ï¼Œè¯·è®°å¾—ç‚¹èµã€æ”¶è—å’Œå…³æ³¨æˆ‘ï¼Œæˆ‘ä¼šæŒç»­æ›´æ–°æ›´å¤šæœ‰ç”¨çš„ç½‘é¡µæŠ€å·§å’Œæ•™ç¨‹ã€‚è°¢è°¢å¤§å®¶ï¼

---
# æ›´å¤šå®è—
ä»£ç æ¨¡æ¿éƒ¨åˆ†å€Ÿé‰´äº[Acwing](https://www.acwing.com/)

ğŸ‡ğŸ‰ğŸŠğŸğŸ‹ğŸ…ğŸ¥ğŸ¥¥ğŸ«’ğŸ«•ğŸ¥—
é¡¹ç›®ä»“åº“çœ‹è¿™é‡ŒğŸ¤—ï¼š
[https://github.com/w-x-x-w](https://github.com/w-x-x-w)
[https://gitee.com/w-_-x](https://gitee.com/w-_-x)
åšå®¢æ–‡ç« çœ‹è¿™é‡ŒğŸ¤­ï¼š
[https://blog.csdn.net/weixin_62650212](https://blog.csdn.net/weixin_62650212)
è§†é¢‘æ¨é€çœ‹è¿™é‡ŒğŸ¤¤ï¼š
[https://space.bilibili.com/1909782963](https://space.bilibili.com/1909782963)
